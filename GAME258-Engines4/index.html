<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>GAME 258</title>
	<link rel="stylesheet" type="text/css" href="../HumberStyle.css" media="all" />
</head>
<body>
	<div id="header"> <b>GAME 258 Game Engines 4 </b><br /></div>
	<ul class="nav">
		<li class="nav"><a class="nav" href="../index.html"> Home </a><br /></li>
		<li class="nav"><a class="nav" href="../MySchedule"> My schedule </a><br /></li>
		<li class="nav"><a class="nav" href="../AboutMe"> About me </a><br /></li>
		<li class="nav"><a class="nav" href="../ETC"> /etc </a><br /></li>
	</ul>
	<div id="rightsidebar">
		<h3> Helpful tools</h3>
		<a class="nav" href="../Rubrics/programmingRubric.html" target="_blank">General Programming Rubric</a><br />
		<hr />
		<a class="nav" href="../GameDev.html"><B>Get GameDev</B></a><br />
		<hr />

		<h3> Base Code </h3>
	
	 
		<a href="Component.h">Component.h</a><br />

		<a href="Actor.h">Actor.h</a><br />
		<a href="Actor.cpp">Actor.cpp</a><br />

		<a href="MeshComponent.h">MeshComponent.h</a><br />
		<a href="MeshComponent.cpp">MeshComponent.cpp</a><br />
		
		<a href="ShaderComponent.h">ShaderComponent.h</a><br />
		<a href="ShaderComponent.cpp">ShaderComponent.cpp</a><br />

		<a href="MaterialComponent.h">MaterialComponent.h</a><br />
		<a href="MaterialComponent.cpp">MaterialComponent.cpp</a><br />

		<a href="MaterialComponent.h">MaterialComponent.h</a><br />
		<a href="MaterialComponent.cpp">MaterialComponent.cpp</a><br />
		
		<a href="CameraActor.cpp">CameraActor.cpp</a><br />
		<a href="CameraActor.h">CameraActor.h</a><br />
		<a href="ChessPieces.zip">ChessPieces.zip</a><br />

		<a href="Texture.cpp">Texture.cpp</a><br />
		<a href="UBO_Padding.h">UBO_Padding.h</a><br />
		<a href="http://www.grinninglizard.com/tinyxml2/index.html">tinyxml-2</a><br />



		<hr />
		<a href="defaultVert.glsl">defaultVert.glsl</a><br />
		<a href="defaultFrag.glsl">defaultFrag.glsl</a><br />
		<a href="textureVert.glsl">textureVert.glsl</a><br />
		<a href="textureFrag.glsl">textureFrag.glsl</a><br />
		<hr />
		<a class="nav" href="../GAME157-Graphics/Mario.obj">Mario.obj</a><br />
		<a class="nav" href="../GAME157-Graphics/Skull.obj">Skull.obj</a><br />
		<a class="nav" href="../GAME157-Graphics/mario_mime.png">mario_mime.png</a><br />
		<a class="nav" href="../GAME157-Graphics/mario_main.png">mario_main.png</a><br />
		<a class="nav" href="../GAME157-Graphics/mario_fire.png">mario_fire.png</a><br />
		<a class="nav" href="../GAME157-Graphics/skull_texture.jpg">skull_texture.jpg</a><br />
		<a class="nav" href="Hammer.obj">Hammer.obj</a><br />
		<a class="nav" href="hammer_BaseColor.png">hammer_BaseColor.png</a><br />
		<hr />
		<a class="nav" href="CheckerPiece.obj">CheckerPiece.obj</a><br />
		<a class="nav" href="../GAME157-Graphics/Plane.obj">Plane.obj</a><br />
		<a class="nav" href="8x8_checkered_board.png">8x8_checkered_board.png</a><br />
		<a class="nav" href="8x8_checkered_board2.png">8x8_checkered_board(red & black)</a><br />
		<a class="nav" href="redCheckerPiece.png">redCheckerPiece.png</a><br />
		<a class="nav" href="blackCheckerPiece.png">blackCheckerPiece.png</a><br />
		<a class="nav" href="whiteCheckerPiece.png">whiteCheckerPiece.png</a><br />
		
		<a class="nav" href="ChessPieces.zip">ChessPieces.zip</a><br />
		<a class="nav" href="colorPickingVert.glsl">colorPickingVert.glsl</a><br />
		<a class="nav" href="colorPickingFrag.glsl">colorPickingFrag.glsl</a><br />
		
		<hr />
		
		<a class="nav" href="XMLProject.zip">XMLProject.zip</a><br />
	</div>

	<H1> Welcome to Game 258 - Game Engines 4 </H1>
	<H3>ECS <u>E</u>ntity <u>C</u>omponent <u>S</u>ystem</H3>
	
	<ul>
		<p>
		</p>
		<li><b>Topic 0:</b> Templates in C++ and other tools<br /></li>

		I did some demos in that horrible classroom last week. <br/>
		The first was just to show you a templated function. The next was to templete
		a class. <br/>
		<a href="../CodeDepot/TemplateDemo.zip">TemplateDemo.zip</a>
		<br />
		I finished by starting the code for an abstract class called Component. <br/>
		I made the argument, no one objected, that I could create a class called Actor that inherits from Component.
		<br />
		This a version of our real starting point
		<a href="../CodeDepot/ComponentFramework25.0.0.zip"> ComponentFramework25.0.0</a>,
		<br />
		download it. We will start by incorporating the demo project into the FrameWork.
		<br />
		</p>
		My next big step is to explain this:
		<textarea class="code" cols=10 rows=8 spellcheck="false">
			/// See universal references in C++11 
			template<typename ComponentTemplate, typename ... Args>
			void AddComponent(Args&& ... args_) {
				ComponentTemplate* componentObject = new ComponentTemplate(std::forward<Args>(args_)...);
				components.push_back(componentObject);
			}
		</textarea>
		

		<p>
		</p>
		<li><b>Topic 1:</b> The Entity (Actor / Component)</li>
		Using the Actor/Component demo code we created over the last one or two classes, begin inserting these ideas in to the framework - I will guide you, promise.
		<br />
		</p>

		
		<p>
		</p>
		<li><b>Topic 2:</b> The Components and Actors</li>
		Let's create some basic components and begin to flesh them out: TransformComponent, MeshComponent, Actor, and CameraActor.
		<br />

		</p>
		<p> This is where we sould all be now as of Jan 31 2025:<br/> <br\>
			<a href="Component.h">Component.h</a><br />
			I appoligize that I didn't cover Actor properly, I hope you all just distracted me and not because of a feeble brain.</br>
			I will explain in full detail<br/>

			<a href="Actor.h">Actor.h</a><br />
			<a href="Actor.cpp">Actor.cpp</a><br />
			
			<a href="MeshComponent.h">MeshComponent.h</a><br />
			<a href="MeshComponent.cpp">MeshComponent.cpp</a><br />

			<a href="ShaderComponent.h">ShaderComponent.h</a><br />
			<a href="ShaderComponent.cpp">ShaderComponent.cpp</a><br />

			<a href="MaterialComponent.h">MaterialComponent.h</a><br />
			<a href="MaterialComponent.cpp">MaterialComponent.cpp</a><br />

			<a href="TransformComponent.h">TransformComponent.h</a><br />
			<a href="TransformComponent.cpp">TransformComponent.cpp</a><br />
		</p>
		
		<p>
		</p>
		<li><b>Topic 3:</b> Using the Components</li>
		In Let's start using the components with the actors
		<br />
		</p>
		

		<p>
		</p>
		<li><b>Topic 4:</b> Using Components to render an Actor in 3D. <i> (Finally some graphics)</i></li>
		Get Mario on the screen!
		<br />
		</li>
		</p>

		<p>
		</p>
		<li><b>Topic 5:</b> Parenting objects </li>
		Once you have mario on the screen, I need you to make the following modification to the Actor class:
		

		<textarea class="code" cols=127 rows=13 spellcheck="false">
		Matrix4 Actor::GetModelMatrix() {
			TransformComponent* transform = GetComponent<TransformComponent>();
			if (transform) {
				modelMatrix = transform->GetTransformMatrix();
			} else {
				modelMatrix.loadIdentity();
			}
			if (parent) { /// <== LOOK AT IT!  Think!
				modelMatrix = dynamic_cast<Actor*>(parent)->GetModelMatrix() * modelMatrix;
			}
			return modelMatrix;
		}
		</Actor*></TransformComponent></textarea>
		<br />
		<br />

		From here you could parent one actor to another. On the website I have a hammer.obj and a texture for it. Can you put
		the hammer in Mario's hand and have it move with him?
		<br />
		</p>
		</li>

		<li>
			<b> Assignment 1: Feb 23</b>
			<p>
				<a href="Assignment1.html">Making a Checkerboard with Checkers </a>
			</p>
		</li>
		
		<li><b>Topic 7:</b> Better Memory Management - Smart Pointers</li>
		In this next section, I'll show you how smart pointers work, and in our current application, how shared_ptr can be helpful.
		<br />
		<br />


		In this next section, we'll look at unique_ptr,  weak_ptr, and why everything should at least be a shared_ptr.
		<br />
		<br />

		<li><b>Topic 8:</b> Better, better Memory Management - Applying smart pointers to the engine</li>
		Based on what we did last week, let's use the following code definition, in the Componentt.h file
		<p>
			<textarea class="code" spellcheck="false" rows=4>

					template<typename T>
					using Ref = std::shared_ptr<T>;

			</textarea><br/>
			You'll need to place #include<memory> header file at the top.	
		</p>
		<br />
		<br />

		Next, we'll need to modifly the Actor.h file a bit to handle this new Ref() definition.
		I can use the std::make_shared idea plus simplify the existing code to look like this:
		<br />

		<textarea class="code" spellcheck="false" rows=11>
		template<typename ComponentTemplate>
		void AddComponent(Ref<ComponentTemplate> component_) {
			if (GetComponent<ComponentTemplate>().get() != nullptr) {
#ifdef _DEBUG
				std::cerr << "WARNING: Trying to add a component type that is already added - ignored\n";
#endif
			return;
		}
		components.push_back(component_);
}	
		</textarea>

		<br />
		<br />
		Delete all the old AddComponent() stuff and add the new stuff to your project.
		<br />
		We will also need to write a overload the AddComponent() method to accept an already existing component.
		This will be necessary for the implimentation of the asset manager. This overload will look very much like
		the one listed above. The easiest approch is just to copy the original and make this simple modification.
		<br />

		<textarea class="code" spellcheck="false" rows=14>
	template<typename ComponentTemplate, typename ... Args>
	void AddComponent(Args&& ... args_) {
		/// before you add the component ask if you have the component in the list already,
		/// if so - don't add a second one. 
		if (GetComponent<ComponentTemplate>().get() != nullptr) {
#ifdef _DEBUG
			std::cerr << "WARNING: Trying to add a component type that is already added - ignored\n";
#endif
			return;
		}
		/// Finish building the component and add the component to the list
		components.push_back(std::make_shared<ComponentTemplate>(std::forward<Args>(args_)...));
	}
	</textarea>
		<br />
		<br />
		Now you are going to need a new GetComponent as well
		<br />
		<textarea class="code" spellcheck="false" rows=13>
	template<typename ComponentTemplate>
	Ref<ComponentTemplate> GetComponent() const {
	for (auto component : components) {
		if (dynamic_cast<ComponentTemplate*>(component.get())) {
			/// This is a dynamic cast designed for shared_ptr's
			/// https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast
			return std::dynamic_pointer_cast<ComponentTemplate>(component);
		}
	}
	return Ref<ComponentTemplate>(nullptr);
}
	</textarea>
	Now on to Actor.cpp, replace RemoveAllComponents() with<br/>
		<textarea class="code" spellcheck="false" rows=5>
	template<typename ComponentTemplate>
	void Actor::RemoveAllComponents() {
		components.clear();
	}
	</textarea>
	In GetModelMatrix() you will only need to change one line. This will be the first time you'll use 
		a Ref to a component.<br/>
		Ref<TransformComponent> transform  = GetComponent<TransformComponent>(); <br/>
		Get it? <br/><br/>


<li>
	<b> Assignment 2: <a href="Assignment2.html">Switch from raw pointers to all Refs (shared_ptr) </a>	
</li><br/>
<li>
<p>
	<b>Topic 9:</b>Systems<br/>
	So far we have looked at Entities (Actors), and Components. Now let's look at the third part - Systems.<br/>
	To start off with, let's look at collisions. In Unity and Unreal they call them colliders. <br/>
	Let's start by creating a ColliderComponent. 
</p>
<p> This is the starting point of the of the collision system. First, define ColliderComponent. 
	This just holds the type of collision object you actor is using, sphere, AABB, and such. Here's the basic code 
	for the Component.<br/>
<textarea class="code" spellcheck="false" rows=41>
#pragma once
#include "TransformComponent.h"
#include <Plane.h>
using namespace MATHEX;

enum class ColliderType {
	SPHERE,
	AABB,
	PLANE,
	
};

/// For an Axis Aligned Bounding Box, their are many ways you could define the box.
/// My favorite way, the easiest to understand way is pick the center location of 
/// the box, then specify the radius from that center in 
/// the x, y,and z dimensions. Umer calls the radius the halfExtent
struct AABB {
	Vec3 center;
	Vec3 halfExtents;
};

class CollisionComponent: public Component {
	friend class CollisionSystem;
    CollisionComponent(const CollisionComponent&) = delete;
	CollisionComponent(CollisionComponent&&) = delete;
	CollisionComponent& operator = (const CollisionComponent&) = delete;
	CollisionComponent& operator = (CollisionComponent&&) = delete;
protected:
	ColliderType colliderType;  
	float radius; /// Sphere collision
	Vec3 halfExtents; /// AABB
	Plane plane; /// Plane 

public:
	CollisionComponent(Component* parent_, float radius_ );
	CollisionComponent(Component* parent_, Vec3 halfExtents_);
	CollisionComponent(Component* parent_, Plane plane_);
	bool OnCreate(){return true;}
	void OnDestroy(){}
	void Update(const float deltaTime_){}
	void Render()const{}
};
</textarea>
	</p>
	Next, let me build a Collision System. Here's the header file:<br/>
	<textarea class="code" spellcheck="false" rows=34>
#pragma once
#include <vector>
#include "CollisionComponent.h"
#include "PhysicsComponent.h"
#include "Actor.h"
#include "Debug.h"
#include <Sphere.h>
using namespace MATH;
using namespace MATHEX;

class CollisionSystem {
private:
    std::vector<Ref<Actor>> collidingActors;
public:
    /// This function will check the the actor being added is new and has the all proper components 
	void AddActor(Ref<Actor> actor_) {
		if(actor_->GetComponent<CollisionComponent>().get() == nullptr){
			Debug::Error("The Actor must have a CollisionComponent - ignored ", __FILE__, __LINE__);
			return;
		}

		if(actor_->GetComponent<PhysicsComponent>().get() == nullptr){
			Debug::Error("The Actor must have a PhysicsComponent - ignored ", __FILE__, __LINE__);
			return;
		}
		collidingActors.push_back(actor_);
	}

	bool CollisionDetection(const Sphere &s1, const Sphere &s2) const; 
	bool CollisionDetection(const AABB &bb1, const AABB &bb2) const; 
	bool CollisionDetection(const Sphere s1, const Plane p1) const;
	void Update(const float deltaTime);
	
};
</p>
<p>
	We will flesh these out in class. Be sure to show up. 
</p>

</li>
<!--
	

<li>
	<b> Assignment 3: <a href="Assignment3.html"> Build an Asset Manager</a><br/>	
</li>
<li>
	<b> Assignment 4: <a href="Assignment4.html"> Color Picking</a><br/>	
</li>

-->
	</ul>

</body>
</HTML>
